## Bindings *Add private Defs.*### Def* Global * Overrides previously declared symbols ```clojure(def object "Jhon")(def object "darkness")(println (str "Hello " object " my old friend"))```> As usual try to avoid global state. ### Let* Bindings can only be used in the expressions scope. Example ```clojure(let [a "Hello, world!"]	(println a))	(println a) ; error```You can have an arbitrary number of bindings```clojure(let [a "Hello, world!"      b "Bye, World!"]	(println a)	(println b))```You can add print statements by suppressing the return value. Very useful for debugging when bindings functions that do actual work.```clojure(let [a "Hello, world!"      _(println a)      b "Bye, World!"      _(println b)]	(println "Done"))```### Scoping * Each expression has its own scope. * Just like in most languages symbol resolution bubbles up.```clojure(let [a "Hello, world!"]  (let [b "Bye, World!"]    (println a) ; Bubbles up to outer scope    (println b)))        ``````clojure(let [a "Outer world!"]  (let [a "Inner world!"]    (println a)) ; Resolves to the first symbol found   (println a)) ; and nothing is overwritten  ``````clojure(let [a "Hello, world!"]  (let [b "Bye, World!"]        (println a))  (println b)) ; Can't drill down into scopes``````clojure(def a "Hello, world!")(let [b "Bye, World!"]      (println a)) ; Globals can be used anywhere```